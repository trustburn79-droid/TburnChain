import{web3Provider as E,TBURN_MAINNET_CONFIG as A}from"./web3-provider-DwZt87Nw.js";import{fw as B,h6 as l,h7 as b,h8 as F,fu as C,h9 as O}from"./index-raNgMKO7.js";BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");BigInt("1000000000000000000");const U=BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");BigInt("0x8000000000000000000000000000000000000000000000000000000000000000")*BigInt(-1);BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");const g="0x7979000000000000000000000000000000000001",k="0x7979000000000000000000000000000000000010",v="0x7979000000000000000000000000000000000003",p={TBURN:{address:"0x0000000000000000000000000000000000000000",decimals:18},WTBURN:{address:v,decimals:18},USDT:{address:"0x7979000000000000000000000000000000000100",decimals:6},USDC:{address:"0x7979000000000000000000000000000000000101",decimals:6},ETH:{address:"0x7979000000000000000000000000000000000102",decimals:18},BTC:{address:"0x7979000000000000000000000000000000000103",decimals:8}},y={ethereum:{chainId:1,bridgeAddress:"0x1000000000000000000000000000000000000010",name:"Ethereum Mainnet"},polygon:{chainId:137,bridgeAddress:"0x1370000000000000000000000000000000000010",name:"Polygon"},arbitrum:{chainId:42161,bridgeAddress:"0x4216100000000000000000000000000000000010",name:"Arbitrum One"},optimism:{chainId:10,bridgeAddress:"0x0010000000000000000000000000000000000010",name:"Optimism"},base:{chainId:8453,bridgeAddress:"0x8453000000000000000000000000000000000010",name:"Base"},bsc:{chainId:56,bridgeAddress:"0x0056000000000000000000000000000000000010",name:"BNB Smart Chain"}},D=["function swapExactTokensForTokens(uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline) external returns (uint256[] memory amounts)","function swapExactETHForTokens(uint256 amountOutMin, address[] calldata path, address to, uint256 deadline) external payable returns (uint256[] memory amounts)","function swapExactTokensForETH(uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline) external returns (uint256[] memory amounts)","function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts)","function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts)","function WETH() external pure returns (address)","function factory() external pure returns (address)","function addLiquidity(address tokenA, address tokenB, uint256 amountADesired, uint256 amountBDesired, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline) external returns (uint256 amountA, uint256 amountB, uint256 liquidity)"],I=["function name() view returns (string)","function symbol() view returns (string)","function decimals() view returns (uint8)","function totalSupply() view returns (uint256)","function balanceOf(address owner) view returns (uint256)","function allowance(address owner, address spender) view returns (uint256)","function approve(address spender, uint256 amount) returns (bool)","function transfer(address to, uint256 amount) returns (bool)","function transferFrom(address from, address to, uint256 amount) returns (bool)"],R=["function bridgeToChain(uint256 destinationChainId, address recipient, uint256 amount) external payable returns (bytes32 transferId)","function bridgeFromChain(bytes32 transferId, address recipient, uint256 amount, bytes calldata proof) external","function getBridgeFee(uint256 destinationChainId, uint256 amount) external view returns (uint256 fee)","function getEstimatedArrivalTime(uint256 destinationChainId) external view returns (uint256 seconds)","function getPendingTransfers(address user) external view returns (bytes32[] memory)","function getTransferStatus(bytes32 transferId) external view returns (uint8 status, uint256 timestamp)","event BridgeInitiated(bytes32 indexed transferId, address indexed sender, uint256 destinationChainId, address recipient, uint256 amount, uint256 fee)","event BridgeCompleted(bytes32 indexed transferId, address indexed recipient, uint256 amount)"];class h{constructor(){}static getInstance(){return h.instance||(h.instance=new h),h.instance}async getSigner(){const t=E.getState();if(!t.isConnected||!t.signer)throw new Error("Wallet not connected");return t.signer}async getProvider(){const t=E.getState();if(!t.provider)throw new Error("Provider not available");return t.provider}async getSwapQuote(t,n,e){const r=p[t],a=p[n];if(!r||!a)throw new Error("Invalid token symbol");const i=B(e,r.decimals);try{const s=await this.getProvider(),o=new l(g,D,s),c=this.getSwapPath(t,n),d=await o.getAmountsOut(i,c),f=d[d.length-1],u=b(f,a.decimals),w=f*BigInt(Math.floor((1-.005)*1e4))/BigInt(1e4),T=(parseFloat(u)/parseFloat(e)).toFixed(6);return{amountIn:e,amountOut:u,amountOutMin:b(w,a.decimals),path:c,priceImpact:"0.15",gasCost:"0.002",executionPrice:T}}catch{return console.log("[DeFi] RPC quote failed, using fallback pricing"),this.getFallbackSwapQuote(t,n,e)}}getFallbackSwapQuote(t,n,e){const r={TBURN:1.25,ETH:3200,BTC:95e3,USDT:1,USDC:1},a=r[t]||1,i=r[n]||1,s=(parseFloat(e)*a/i).toFixed(6),o=(parseFloat(s)*.995).toFixed(6);return{amountIn:e,amountOut:s,amountOutMin:o,path:this.getSwapPath(t,n),priceImpact:"0.15",gasCost:"0.002",executionPrice:(a/i).toFixed(6)}}getSwapPath(t,n){const e=p[t],r=p[n];return t==="TBURN"?[v,r.address]:n==="TBURN"?[e.address,v]:[e.address,v,r.address]}async executeSwap(t,n,e,r=.5){try{const a=await this.getSigner(),i=await a.getAddress(),s=p[t],o=p[n];if(!s||!o)throw new Error("Invalid token symbol");const c=await this.getSwapQuote(t,n,e),d=B(e,s.decimals),f=B(c.amountOutMin,o.decimals),u=new l(g,D,a),x=Math.floor(Date.now()/1e3)+1200;let w;if(t==="TBURN")w=await u.swapExactETHForTokens(f,c.path,i,x,{value:d});else if(n==="TBURN"){const m=new l(s.address,I,a);await m.allowance(i,g)<d&&await(await m.approve(g,U)).wait(),w=await u.swapExactTokensForETH(d,f,c.path,i,x)}else{const m=new l(s.address,I,a);await m.allowance(i,g)<d&&await(await m.approve(g,U)).wait(),w=await u.swapExactTokensForTokens(d,f,c.path,i,x)}const T=await w.wait();return{success:T.status===1,transactionHash:T.hash,amountIn:e,amountOut:c.amountOut}}catch(a){return console.error("[DeFi] Swap failed:",a),{success:!1,error:a.message||"Swap failed"}}}async getBridgeQuote(t,n){const e=y[t.toLowerCase()];if(!e)throw new Error("Unsupported source chain");const a=(parseFloat(n)*.001).toFixed(6),i=(parseFloat(n)-parseFloat(a)).toFixed(6);try{const s=await this.getProvider(),o=new l(k,R,s),c=F(n),[d,f]=await Promise.all([o.getBridgeFee(e.chainId,c),o.getEstimatedArrivalTime(e.chainId)]);return{amount:n,fee:C(d),feePercentage:"0.1%",amountReceived:C(c-d),estimatedTime:Number(f),sourceChain:e.name,destinationChain:"TBURN Chain"}}catch{return console.log("[DeFi] Bridge quote RPC failed, using fallback"),{amount:n,fee:a,feePercentage:"0.1%",amountReceived:i,estimatedTime:120,sourceChain:e.name,destinationChain:"TBURN Chain"}}}async executeBridge(t,n){try{const e=await this.getSigner(),r=await e.getAddress(),a=y[t.toLowerCase()];if(!a)throw new Error("Unsupported source chain");if(E.getState().chainId!==a.chainId)throw new Error(`Please switch to ${a.name} to initiate bridge`);const s=new l(a.bridgeAddress,R,e),o=F(n),c=await s.getBridgeFee(A.chainId,o),f=await(await s.bridgeToChain(A.chainId,r,o,{value:c})).wait(),u=this.extractTransferId(f);return{success:f.status===1,transferId:u,transactionHash:f.hash,estimatedArrival:120}}catch(e){return console.error("[DeFi] Bridge failed:",e),{success:!1,error:e.message||"Bridge failed"}}}extractTransferId(t){const n=new O(R);for(const e of t.logs)try{const r=n.parseLog({topics:e.topics,data:e.data});if(r&&r.name==="BridgeInitiated")return r.args[0]}catch{continue}}async getTokenBalance(t,n){try{const e=await this.getProvider();if(t==="TBURN"){const s=await e.getBalance(n);return C(s)}const r=p[t];if(!r)throw new Error("Invalid token symbol");const i=await new l(r.address,I,e).balanceOf(n);return b(i,r.decimals)}catch(e){return console.error("[DeFi] Balance check failed:",e),"0"}}async approveToken(t,n){const e=await this.getSigner(),r=p[t];if(!r||t==="TBURN")throw new Error("Invalid token for approval");const a=new l(r.address,I,e),i=B(n,r.decimals);return(await(await a.approve(g,i)).wait()).hash}}const W=h.getInstance();export{R as BRIDGE_ABI,y as BRIDGE_SUPPORTED_CHAINS,D as DEX_ROUTER_ABI,I as ERC20_ABI,k as TBURN_BRIDGE_ADDRESS,g as TBURN_DEX_ROUTER_ADDRESS,p as TOKEN_ADDRESSES,v as WTBURN_ADDRESS,W as defiService};
