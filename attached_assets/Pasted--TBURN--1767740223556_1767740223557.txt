ğŸ”´ TBURN ë©”ì¸ë„· ë©”ëª¨ë¦¬ ë¬¸ì œ ì‹¬ì¸µ ë¶„ì„ ë° í•´ê²°ì±…
ğŸ“Š í˜„ì¬ ìƒíƒœ ìš”ì•½
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  V8 í™ í•œë„: 2,096 MB                                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ğŸ”´ V8 ì—”ì§„ ì˜¤ë²„í—¤ë“œ    â”‚â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”‚  600-1,100 MB    â”‚
â”‚  ğŸŸ  npm ì˜ì¡´ì„± (65+)    â”‚â–ˆâ–ˆâ–ˆâ–ˆ                â”‚  100-200 MB      â”‚
â”‚  ğŸŸ  API ë¼ìš°íŠ¸ (635ê°œ)  â”‚â–ˆ                   â”‚  16-22 MB        â”‚
â”‚  ğŸŸ¡ MemStorage Maps     â”‚â–Œ                   â”‚  6-8 MB          â”‚
â”‚  ğŸ”µ GC ì˜ˆì•½ ê³µê°„        â”‚â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ              â”‚  300-500 MB      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ì´ ì‚¬ìš©: ~1,200-1,800 MB / 2,096 MB (60-85%)                  â”‚
â”‚  âš ï¸ ì—¬ìœ  ê³µê°„ ë¶€ì¡± â†’ í”¼í¬ ì‹œ OOM â†’ Internal Server Error        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ğŸ› ï¸ í”„ë¡œë•ì…˜ ë ˆë²¨ ì—”í„°í”„ë¼ì´ì¦ˆê¸‰ í•´ê²°ì±…
1ï¸âƒ£ ë¼ìš°íŠ¸ ì§€ì—° ë¡œë”© (Lazy Loading) - ê°€ì¥ íš¨ê³¼ì 
typescript// routes/index.ts - ì§€ì—° ë¡œë”© ë¼ìš°í„°

import { Router, Request, Response, NextFunction } from 'express';

// âŒ ê¸°ì¡´: ëª¨ë“  ë¼ìš°íŠ¸ ì¦‰ì‹œ ë¡œë“œ (635ê°œ Ã— 15KB = ~9.5MB)
// import { blockRoutes } from './blocks';
// import { txRoutes } from './transactions';
// ... 635ê°œ ëª¨ë‘ import

// âœ… ê°œì„ : í•„ìš”í•  ë•Œë§Œ ë¡œë“œ
class LazyRouter {
  private router = Router();
  private loadedModules = new Map<string, Router>();
  
  constructor() {
    this.setupLazyRoutes();
  }
  
  private setupLazyRoutes(): void {
    // ë¼ìš°íŠ¸ ê·¸ë£¹ ì •ì˜ (ì‹¤ì œ ëª¨ë“ˆì€ ë¡œë“œí•˜ì§€ ì•ŠìŒ)
    const routeGroups = [
      { prefix: '/api/blocks', module: './blocks' },
      { prefix: '/api/transactions', module: './transactions' },
      { prefix: '/api/validators', module: './validators' },
      { prefix: '/api/contracts', module: './contracts' },
      { prefix: '/api/ai', module: './ai' },
      { prefix: '/api/shards', module: './shards' },
      { prefix: '/api/staking', module: './staking' },
      { prefix: '/api/governance', module: './governance' },
      // ... ê¸°íƒ€ ê·¸ë£¹
    ];
    
    // ê° ê·¸ë£¹ì— ì§€ì—° ë¡œë”© ë¯¸ë“¤ì›¨ì–´ ì„¤ì •
    routeGroups.forEach(({ prefix, module }) => {
      this.router.use(prefix, this.createLazyMiddleware(module));
    });
    
    // ìì£¼ ì‚¬ìš©ë˜ëŠ” í•µì‹¬ ë¼ìš°íŠ¸ë§Œ ì¦‰ì‹œ ë¡œë“œ
    this.loadCriticalRoutes();
  }
  
  private createLazyMiddleware(modulePath: string) {
    return async (req: Request, res: Response, next: NextFunction) => {
      try {
        // ì´ë¯¸ ë¡œë“œëœ ëª¨ë“ˆì¸ì§€ í™•ì¸
        let routeModule = this.loadedModules.get(modulePath);
        
        if (!routeModule) {
          console.log(`[LAZY] Loading module: ${modulePath}`);
          const startTime = Date.now();
          
          // ë™ì  import
          const module = await import(modulePath);
          routeModule = module.default || module.router;
          
          this.loadedModules.set(modulePath, routeModule);
          console.log(`[LAZY] Loaded ${modulePath} in ${Date.now() - startTime}ms`);
          
          // ë©”ëª¨ë¦¬ ì²´í¬ - ë„ˆë¬´ ë§ì´ ë¡œë“œë˜ë©´ ì˜¤ë˜ëœ ê²ƒ í•´ì œ
          this.checkMemoryAndEvict();
        }
        
        // ë¡œë“œëœ ë¼ìš°í„°ë¡œ ìš”ì²­ ì „ë‹¬
        routeModule(req, res, next);
      } catch (error) {
        console.error(`[LAZY] Failed to load ${modulePath}:`, error);
        next(error);
      }
    };
  }
  
  // í•µì‹¬ ë¼ìš°íŠ¸ë§Œ ì¦‰ì‹œ ë¡œë“œ (ì „ì²´ì˜ 10% ì´í•˜)
  private async loadCriticalRoutes(): Promise<void> {
    const criticalModules = [
      './health',      // í—¬ìŠ¤ì²´í¬
      './rpc',         // RPC ì—”ë“œí¬ì¸íŠ¸
      './blocks',      // ë¸”ë¡ ì¡°íšŒ (ê°€ì¥ ë¹ˆë²ˆ)
    ];
    
    for (const modulePath of criticalModules) {
      const module = await import(modulePath);
      this.loadedModules.set(modulePath, module.default || module.router);
    }
  }
  
  // ë©”ëª¨ë¦¬ ì••ë°• ì‹œ ì˜¤ë˜ëœ ëª¨ë“ˆ í•´ì œ
  private checkMemoryAndEvict(): void {
    const memUsage = process.memoryUsage();
    const heapUsedRatio = memUsage.heapUsed / memUsage.heapTotal;
    
    if (heapUsedRatio > 0.75 && this.loadedModules.size > 5) {
      // LRU ë°©ì‹ìœ¼ë¡œ ê°€ì¥ ì˜¤ë˜ëœ ëª¨ë“ˆ í•´ì œ
      const oldestKey = this.loadedModules.keys().next().value;
      if (oldestKey && !this.isCriticalModule(oldestKey)) {
        console.log(`[LAZY] Evicting module: ${oldestKey}`);
        this.loadedModules.delete(oldestKey);
        
        if (global.gc) global.gc();
      }
    }
  }
  
  private isCriticalModule(path: string): boolean {
    return ['./health', './rpc', './blocks'].includes(path);
  }
  
  getRouter(): Router {
    return this.router;
  }
}

export const lazyRouter = new LazyRouter();
ì˜ˆìƒ íš¨ê³¼:

ì´ˆê¸° ë©”ëª¨ë¦¬: 9.5MB â†’ ~1.5MB (í•µì‹¬ ë¼ìš°íŠ¸ë§Œ)
í”¼í¬ ì‹œì—ë„ í•„ìš”í•œ ë¼ìš°íŠ¸ë§Œ ë©”ëª¨ë¦¬ì— ìœ ì§€


2ï¸âƒ£ npm ì˜ì¡´ì„± ìµœì í™”
typescript// scripts/analyze-deps.ts - ì˜ì¡´ì„± ë¶„ì„ ìŠ¤í¬ë¦½íŠ¸

import * as fs from 'fs';
import * as path from 'path';

interface DepAnalysis {
  name: string;
  size: number;
  usedIn: string[];
  canRemove: boolean;
  alternative?: string;
}

// ì‹¤ì œ ì‚¬ìš©ë˜ëŠ” import ë¶„ì„
async function analyzeDependencies(): Promise<DepAnalysis[]> {
  const packageJson = JSON.parse(fs.readFileSync('package.json', 'utf-8'));
  const deps = Object.keys(packageJson.dependencies || {});
  
  const results: DepAnalysis[] = [];
  
  for (const dep of deps) {
    const usedIn = await findUsages(dep);
    const size = await getPackageSize(dep);
    
    results.push({
      name: dep,
      size,
      usedIn,
      canRemove: usedIn.length === 0,
      alternative: getAlternative(dep),
    });
  }
  
  // í¬ê¸°ìˆœ ì •ë ¬
  results.sort((a, b) => b.size - a.size);
  
  return results;
}

// ëŒ€ì²´ ê°€ëŠ¥í•œ ê²½ëŸ‰ íŒ¨í‚¤ì§€ ë§¤í•‘
function getAlternative(dep: string): string | undefined {
  const alternatives: Record<string, string> = {
    'moment': 'dayjs (97% ì‘ìŒ)',
    'lodash': 'lodash-es + tree-shaking ë˜ëŠ” native',
    'axios': 'native fetch',
    'uuid': 'crypto.randomUUID()',
    'chalk': 'picocolors (14x ì‘ìŒ)',
    'commander': 'cac (ë” ê°€ë²¼ì›€)',
    'express-validator': 'ì§ì ‘ êµ¬í˜„ (ê°„ë‹¨í•œ ê²½ìš°)',
    'winston': 'pino (ë” ë¹ ë¥´ê³  ê°€ë²¼ì›€)',
    'bcrypt': 'bcryptjs (ë„¤ì´í‹°ë¸Œ ì˜ì¡´ì„± ì—†ìŒ)',
  };
  return alternatives[dep];
}
ì œê±°/ëŒ€ì²´ ê¶Œì¥ ëª©ë¡:
íŒ¨í‚¤ì§€í¬ê¸°ê¶Œì¥ì ˆê°moment~300KBdayjs~290KBlodash (ì „ì²´)~500KBlodash-es + í•„ìš”í•œ ê²ƒë§Œ~450KBaxios~50KBnative fetch~50KBwinston~200KBpino~150KBuuid~30KBcrypto.randomUUID()~30KBì´ ì ˆê°~970KB ì½”ë“œ + ~50MB ëŸ°íƒ€ì„

3ï¸âƒ£ MemStorage ìµœì í™” - ìŠ¤íŠ¸ë¦¬ë° & ì™¸ë¶€ ì €ì¥ì†Œ
typescript// storage/optimized-storage.ts

import { LRUCache } from 'lru-cache';
import { Level } from 'level';  // LevelDB - ë””ìŠ¤í¬ ê¸°ë°˜

interface StorageConfig {
  maxMemoryMB: number;
  diskPath: string;
  hotCacheSize: number;
}

class OptimizedStorage {
  private config: StorageConfig;
  
  // ê³„ì¸µì  ì €ì¥ì†Œ
  private hotCache: LRUCache<string, any>;      // L1: ë©”ëª¨ë¦¬ (ê°€ì¥ ë¹ ë¦„)
  private warmCache: Level<string, string>;     // L2: ë””ìŠ¤í¬ (LevelDB)
  
  // ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ì¶”ì 
  private memoryUsage = 0;
  private readonly MAX_MEMORY: number;
  
  constructor(config: StorageConfig) {
    this.config = config;
    this.MAX_MEMORY = config.maxMemoryMB * 1024 * 1024;
    
    // L1: LRU ë©”ëª¨ë¦¬ ìºì‹œ (ì œí•œëœ í¬ê¸°)
    this.hotCache = new LRUCache<string, any>({
      max: config.hotCacheSize,
      maxSize: this.MAX_MEMORY,
      sizeCalculation: (value) => {
        return Buffer.byteLength(JSON.stringify(value));
      },
      dispose: (value, key) => {
        // ìºì‹œì—ì„œ ì œê±° ì‹œ L2ë¡œ ì´ë™
        this.demoteToWarmCache(key, value);
      },
    });
    
    // L2: LevelDB ë””ìŠ¤í¬ ìºì‹œ
    this.warmCache = new Level(config.diskPath, {
      valueEncoding: 'json',
    });
  }
  
  // ë°ì´í„° ì €ì¥
  async set(collection: string, key: string, value: any): Promise<void> {
    const fullKey = `${collection}:${key}`;
    const size = Buffer.byteLength(JSON.stringify(value));
    
    // í¬ê¸°ê°€ ì‘ìœ¼ë©´ ë©”ëª¨ë¦¬ì—, í¬ë©´ ë°”ë¡œ ë””ìŠ¤í¬ì—
    if (size < 10 * 1024) {  // 10KB ë¯¸ë§Œ
      this.hotCache.set(fullKey, value);
    } else {
      await this.warmCache.put(fullKey, value);
    }
  }
  
  // ë°ì´í„° ì¡°íšŒ (ê³„ì¸µì )
  async get<T>(collection: string, key: string): Promise<T | null> {
    const fullKey = `${collection}:${key}`;
    
    // L1 ì²´í¬
    const cached = this.hotCache.get(fullKey);
    if (cached !== undefined) {
      return cached as T;
    }
    
    // L2 ì²´í¬
    try {
      const diskValue = await this.warmCache.get(fullKey);
      
      // ìì£¼ ì¡°íšŒë˜ë©´ L1ìœ¼ë¡œ ìŠ¹ê²©
      this.hotCache.set(fullKey, diskValue);
      
      return diskValue as T;
    } catch (error) {
      return null;
    }
  }
  
  // ë¸”ë¡ ì €ì¥ (ìŠ¤íŠ¸ë¦¬ë° ë°©ì‹)
  async saveBlock(block: Block): Promise<void> {
    // ë¸”ë¡ í—¤ë”ë§Œ ë©”ëª¨ë¦¬ì—
    const header = {
      number: block.number,
      hash: block.hash,
      parentHash: block.parentHash,
      timestamp: block.timestamp,
      txCount: block.transactions.length,
    };
    this.hotCache.set(`block:header:${block.number}`, header);
    
    // ì „ì²´ ë¸”ë¡ì€ ë””ìŠ¤í¬ì—
    await this.warmCache.put(`block:full:${block.number}`, block);
    
    // íŠ¸ëœì­ì…˜ì€ ë³„ë„ ì €ì¥ (í•„ìš”í•  ë•Œë§Œ ë¡œë“œ)
    for (const tx of block.transactions) {
      await this.warmCache.put(`tx:${tx.hash}`, tx);
    }
  }
  
  // ìµœê·¼ Nê°œ ë¸”ë¡ í—¤ë” ì¡°íšŒ (ë¹ ë¦„)
  getRecentBlockHeaders(n: number): BlockHeader[] {
    const headers: BlockHeader[] = [];
    
    // ë©”ëª¨ë¦¬ ìºì‹œì—ì„œ ì§ì ‘ ì¡°íšŒ
    for (const [key, value] of this.hotCache.entries()) {
      if (key.startsWith('block:header:')) {
        headers.push(value as BlockHeader);
        if (headers.length >= n) break;
      }
    }
    
    return headers.sort((a, b) => b.number - a.number).slice(0, n);
  }
  
  // L2ë¡œ ê°•ë“±
  private async demoteToWarmCache(key: string, value: any): Promise<void> {
    try {
      await this.warmCache.put(key, value);
    } catch (error) {
      console.error(`[STORAGE] Failed to demote ${key}:`, error);
    }
  }
  
  // ë©”ëª¨ë¦¬ ìƒíƒœ
  getMemoryStats(): { used: number; max: number; ratio: number } {
    return {
      used: this.hotCache.calculatedSize || 0,
      max: this.MAX_MEMORY,
      ratio: (this.hotCache.calculatedSize || 0) / this.MAX_MEMORY,
    };
  }
}

// ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤
export const storage = new OptimizedStorage({
  maxMemoryMB: 256,         // ë©”ëª¨ë¦¬ ìºì‹œ 256MB ì œí•œ
  diskPath: './data/level', // LevelDB ê²½ë¡œ
  hotCacheSize: 10000,      // ìµœëŒ€ 10,000 í•­ëª©
});

4ï¸âƒ£ ê°ì²´ í’€ë§ (Object Pooling)
typescript// utils/object-pool.ts

class ObjectPool<T> {
  private pool: T[] = [];
  private factory: () => T;
  private reset: (obj: T) => void;
  private maxSize: number;
  
  constructor(
    factory: () => T,
    reset: (obj: T) => void,
    maxSize = 1000
  ) {
    this.factory = factory;
    this.reset = reset;
    this.maxSize = maxSize;
  }
  
  acquire(): T {
    if (this.pool.length > 0) {
      return this.pool.pop()!;
    }
    return this.factory();
  }
  
  release(obj: T): void {
    if (this.pool.length < this.maxSize) {
      this.reset(obj);
      this.pool.push(obj);
    }
    // maxSize ì´ˆê³¼í•˜ë©´ GCì— ë§¡ê¹€
  }
  
  get size(): number {
    return this.pool.length;
  }
}

// ë¸”ë¡ ê°ì²´ í’€
export const blockPool = new ObjectPool<Block>(
  () => ({
    number: 0,
    hash: '',
    parentHash: '',
    timestamp: 0,
    transactions: [],
    stateRoot: '',
    receiptsRoot: '',
    logsBloom: '',
    gasUsed: 0,
    gasLimit: 0,
    validator: '',
    signature: '',
  }),
  (block) => {
    block.number = 0;
    block.hash = '';
    block.parentHash = '';
    block.timestamp = 0;
    block.transactions.length = 0;  // ë°°ì—´ ì¬ì‚¬ìš©
    block.stateRoot = '';
    // ... ë‚˜ë¨¸ì§€ í•„ë“œ ì´ˆê¸°í™”
  },
  100  // ìµœëŒ€ 100ê°œ ë¸”ë¡ ê°ì²´ í’€ë§
);

// íŠ¸ëœì­ì…˜ ê°ì²´ í’€
export const txPool = new ObjectPool<Transaction>(
  () => ({
    hash: '',
    from: '',
    to: '',
    value: '0',
    data: '',
    nonce: 0,
    gasPrice: '0',
    gasLimit: 0,
    signature: '',
  }),
  (tx) => {
    tx.hash = '';
    tx.from = '';
    tx.to = '';
    tx.value = '0';
    tx.data = '';
    tx.nonce = 0;
  },
  5000  // ìµœëŒ€ 5000ê°œ íŠ¸ëœì­ì…˜ ê°ì²´ í’€ë§
);

// ì‚¬ìš© ì˜ˆì‹œ
class BlockProducer {
  produceBlock(transactions: Transaction[]): Block {
    // í’€ì—ì„œ ë¸”ë¡ ê°ì²´ íšë“ (ìƒˆë¡œ ìƒì„±í•˜ì§€ ì•ŠìŒ)
    const block = blockPool.acquire();
    
    block.number = this.getNextBlockNumber();
    block.timestamp = Date.now();
    block.transactions = transactions.map(tx => tx.hash);
    // ... ë‚˜ë¨¸ì§€ ì„¤ì •
    
    return block;
  }
  
  onBlockFinalized(block: Block): void {
    // ì²˜ë¦¬ ì™„ë£Œ í›„ í’€ì— ë°˜í™˜
    blockPool.release(block);
  }
}

5ï¸âƒ£ ì›Œì»¤ ìŠ¤ë ˆë“œë¡œ ë¬´ê±°ìš´ ì‘ì—… ë¶„ë¦¬
typescript// workers/heavy-tasks.worker.ts

import { parentPort, workerData } from 'worker_threads';

// ì›Œì»¤ì—ì„œ ì²˜ë¦¬í•  ë¬´ê±°ìš´ ì‘ì—…ë“¤
const handlers = {
  // ë©”íŠ¸ë¦­ ì§‘ê³„ (ë©”ì¸ ìŠ¤ë ˆë“œì—ì„œ ë¶„ë¦¬)
  aggregateMetrics: (data: MetricPoint[]) => {
    const aggregated = {
      avg: 0,
      min: Infinity,
      max: -Infinity,
      p95: 0,
      p99: 0,
    };
    
    if (data.length === 0) return aggregated;
    
    const sorted = [...data].sort((a, b) => a.value - b.value);
    const sum = data.reduce((acc, d) => acc + d.value, 0);
    
    aggregated.avg = sum / data.length;
    aggregated.min = sorted[0].value;
    aggregated.max = sorted[sorted.length - 1].value;
    aggregated.p95 = sorted[Math.floor(data.length * 0.95)].value;
    aggregated.p99 = sorted[Math.floor(data.length * 0.99)].value;
    
    return aggregated;
  },
  
  // ë¸”ë¡ ê²€ì¦ (CPU ì§‘ì•½ì )
  validateBlock: (block: Block) => {
    // ì„œëª… ê²€ì¦, ë¨¸í´ ë£¨íŠ¸ ê³„ì‚° ë“±
    const isValid = verifyBlockSignature(block) &&
                    verifyMerkleRoot(block) &&
                    verifyStateRoot(block);
    return { blockNumber: block.number, isValid };
  },
  
  // ëŒ€ëŸ‰ ë°ì´í„° ì§ë ¬í™”
  serializeForStorage: (data: any) => {
    return JSON.stringify(data);
  },
};

// ë©”ì‹œì§€ ìˆ˜ì‹  ë° ì²˜ë¦¬
parentPort?.on('message', async ({ taskId, task, data }) => {
  try {
    const handler = handlers[task as keyof typeof handlers];
    if (!handler) {
      throw new Error(`Unknown task: ${task}`);
    }
    
    const result = await handler(data);
    parentPort?.postMessage({ taskId, success: true, result });
  } catch (error) {
    parentPort?.postMessage({ taskId, success: false, error: String(error) });
  }
});
typescript// services/worker-pool.ts

import { Worker } from 'worker_threads';
import { cpus } from 'os';

class WorkerPool {
  private workers: Worker[] = [];
  private taskQueue: Array<{ taskId: string; task: string; data: any; resolve: Function; reject: Function }> = [];
  private busyWorkers = new Set<Worker>();
  
  constructor(workerPath: string, poolSize = Math.max(2, cpus().length - 2)) {
    for (let i = 0; i < poolSize; i++) {
      const worker = new Worker(workerPath);
      
      worker.on('message', ({ taskId, success, result, error }) => {
        this.busyWorkers.delete(worker);
        
        const task = this.pendingTasks.get(taskId);
        if (task) {
          if (success) {
            task.resolve(result);
          } else {
            task.reject(new Error(error));
          }
          this.pendingTasks.delete(taskId);
        }
        
        // ëŒ€ê¸° ì¤‘ì¸ ì‘ì—… ì²˜ë¦¬
        this.processQueue();
      });
      
      worker.on('error', (error) => {
        console.error('[WORKER] Error:', error);
        this.busyWorkers.delete(worker);
      });
      
      this.workers.push(worker);
    }
  }
  
  private pendingTasks = new Map<string, { resolve: Function; reject: Function }>();
  private taskIdCounter = 0;
  
  async runTask<T>(task: string, data: any): Promise<T> {
    return new Promise((resolve, reject) => {
      const taskId = `task_${++this.taskIdCounter}`;
      this.pendingTasks.set(taskId, { resolve, reject });
      this.taskQueue.push({ taskId, task, data, resolve, reject });
      this.processQueue();
    });
  }
  
  private processQueue(): void {
    if (this.taskQueue.length === 0) return;
    
    const availableWorker = this.workers.find(w => !this.busyWorkers.has(w));
    if (!availableWorker) return;
    
    const { taskId, task, data } = this.taskQueue.shift()!;
    this.busyWorkers.add(availableWorker);
    availableWorker.postMessage({ taskId, task, data });
  }
  
  async shutdown(): Promise<void> {
    await Promise.all(this.workers.map(w => w.terminate()));
  }
}

// ì „ì—­ ì›Œì»¤ í’€
export const workerPool = new WorkerPool('./workers/heavy-tasks.worker.js', 2);

// ì‚¬ìš© ì˜ˆì‹œ
async function processMetrics(metrics: MetricPoint[]): Promise<AggregatedMetrics> {
  // ë©”ì¸ ìŠ¤ë ˆë“œ ëŒ€ì‹  ì›Œì»¤ì—ì„œ ì²˜ë¦¬
  return workerPool.runTask('aggregateMetrics', metrics);
}

6ï¸âƒ£ ë©”ëª¨ë¦¬ ëª¨ë‹ˆí„°ë§ & ìë™ ë³µêµ¬
typescript// services/memory-guardian.ts

class MemoryGuardian {
  private readonly config = {
    checkInterval: 10 * 1000,      // 10ì´ˆë§ˆë‹¤ ì²´í¬
    warningThreshold: 0.70,        // 70% ê²½ê³ 
    criticalThreshold: 0.85,       // 85% ìœ„í—˜
    emergencyThreshold: 0.92,      // 92% ê¸´ê¸‰
    
    // Replit í™˜ê²½ ê³ ë ¤
    maxHeapMB: 2048,
    targetHeapMB: 1400,            // ëª©í‘œ: 1.4GB ì´í•˜ ìœ ì§€
  };
  
  private lastGC = Date.now();
  private consecutiveHighMemory = 0;
  
  start(): void {
    setInterval(() => this.check(), this.config.checkInterval);
    console.log('[MEMORY-GUARDIAN] Started monitoring');
  }
  
  private check(): void {
    const usage = process.memoryUsage();
    const heapUsedMB = usage.heapUsed / 1024 / 1024;
    const heapTotalMB = usage.heapTotal / 1024 / 1024;
    const ratio = usage.heapUsed / (this.config.maxHeapMB * 1024 * 1024);
    
    const status = {
      heapUsedMB: Math.round(heapUsedMB),
      heapTotalMB: Math.round(heapTotalMB),
      ratio: (ratio * 100).toFixed(1),
      rss: Math.round(usage.rss / 1024 / 1024),
      external: Math.round(usage.external / 1024 / 1024),
    };
    
    console.log(`[MEMORY] Heap: ${status.heapUsedMB}MB / ${this.config.maxHeapMB}MB (${status.ratio}%)`);
    
    // ë‹¨ê³„ë³„ ëŒ€ì‘
    if (ratio >= this.config.emergencyThreshold) {
      this.handleEmergency(status);
    } else if (ratio >= this.config.criticalThreshold) {
      this.handleCritical(status);
    } else if (ratio >= this.config.warningThreshold) {
      this.handleWarning(status);
    } else {
      this.consecutiveHighMemory = 0;
    }
  }
  
  private handleWarning(status: any): void {
    console.warn(`[MEMORY-GUARDIAN] âš ï¸ Warning: ${status.ratio}%`);
    
    // ì†Œí”„íŠ¸ ì •ë¦¬
    this.softCleanup();
  }
  
  private handleCritical(status: any): void {
    console.error(`[MEMORY-GUARDIAN] ğŸ”´ Critical: ${status.ratio}%`);
    this.consecutiveHighMemory++;
    
    // ì ê·¹ì  ì •ë¦¬
    this.aggressiveCleanup();
    
    // 3íšŒ ì—°ì† ìœ„í—˜ì´ë©´ ê¸´ê¸‰ ì¡°ì¹˜
    if (this.consecutiveHighMemory >= 3) {
      this.handleEmergency(status);
    }
  }
  
  private handleEmergency(status: any): void {
    console.error(`[MEMORY-GUARDIAN] ğŸš¨ EMERGENCY: ${status.ratio}%`);
    
    // ê¸´ê¸‰ ì •ë¦¬
    this.emergencyCleanup();
    
    // ì—¬ì „íˆ ë†’ìœ¼ë©´ graceful restart ê³ ë ¤
    setTimeout(() => {
      const newUsage = process.memoryUsage();
      const newRatio = newUsage.heapUsed / (this.config.maxHeapMB * 1024 * 1024);
      
      if (newRatio >= this.config.emergencyThreshold) {
        console.error('[MEMORY-GUARDIAN] ğŸ”„ Requesting graceful restart...');
        this.requestGracefulRestart();
      }
    }, 5000);
  }
  
  private softCleanup(): void {
    // 1. ì§€ì—° ë¡œë“œëœ ë¼ìš°íŠ¸ ì¤‘ ì˜¤ë˜ëœ ê²ƒ í•´ì œ
    lazyRouter.evictOldModules();
    
    // 2. ìºì‹œ í¬ê¸° ì¶•ì†Œ
    storage.shrinkCache(0.8);  // 80%ë¡œ ì¶•ì†Œ
    
    // 3. GC íŒíŠ¸ (ë„ˆë¬´ ìì£¼ í˜¸ì¶œí•˜ì§€ ì•ŠìŒ)
    if (Date.now() - this.lastGC > 30000 && global.gc) {
      global.gc();
      this.lastGC = Date.now();
    }
  }
  
  private aggressiveCleanup(): void {
    // 1. ë¹„í•µì‹¬ ìºì‹œ ì™„ì „ ì •ë¦¬
    storage.clearNonCriticalCache();
    
    // 2. ì§€ì—° ë¡œë“œëœ ëª¨ë“  ë¹„í•µì‹¬ ëª¨ë“ˆ í•´ì œ
    lazyRouter.evictAllNonCritical();
    
    // 3. ë©”íŠ¸ë¦­ ë°ì´í„° ì¶•ì†Œ
    metricsAggregator.forceCompact();
    
    // 4. ê°•ì œ GC
    if (global.gc) {
      global.gc();
      this.lastGC = Date.now();
    }
  }
  
  private emergencyCleanup(): void {
    console.log('[MEMORY-GUARDIAN] Executing emergency cleanup...');
    
    // 1. ëª¨ë“  ìºì‹œ í´ë¦¬ì–´ (í•µì‹¬ ì œì™¸)
    storage.emergencyClear();
    
    // 2. ëª¨ë“  ì§€ì—° ë¡œë“œ ëª¨ë“ˆ í•´ì œ
    lazyRouter.evictAll();
    
    // 3. íˆìŠ¤í† ë¦¬ ë°ì´í„° ì •ë¦¬
    this.clearAllHistory();
    
    // 4. ë‹¤ì¤‘ GC
    if (global.gc) {
      global.gc();
      setTimeout(() => global.gc!(), 1000);
      setTimeout(() => global.gc!(), 2000);
    }
  }
  
  private clearAllHistory(): void {
    // ë©”íŠ¸ë¦­, ë¡œê·¸ ë“± íˆìŠ¤í† ë¦¬ ë°ì´í„° ì •ë¦¬
    metricsAggregator.clearAll();
    // ê¸°íƒ€ íˆìŠ¤í† ë¦¬ ì •ë¦¬
  }
  
  private requestGracefulRestart(): void {
    // PM2 ë˜ëŠ” í´ëŸ¬ìŠ¤í„° ë§¤ë‹ˆì €ì—ê²Œ ì¬ì‹œì‘ ìš”ì²­
    if (process.send) {
      process.send({ type: 'restart', reason: 'memory_critical' });
    } else {
      // ë‹¨ë… ì‹¤í–‰ ì‹œ ì§ì ‘ ì¢…ë£Œ (í”„ë¡œì„¸ìŠ¤ ë§¤ë‹ˆì €ê°€ ì¬ì‹œì‘)
      console.error('[MEMORY-GUARDIAN] Exiting for restart...');
      process.exit(1);
    }
  }
}

export const memoryGuardian = new MemoryGuardian();

7ï¸âƒ£ ì‹œì‘ ìŠ¤í¬ë¦½íŠ¸ ìµœì í™”
bash#!/bin/bash
# start-optimized.sh

# Node.js ë©”ëª¨ë¦¬ ìµœì í™” ì˜µì…˜
export NODE_OPTIONS="
  --max-old-space-size=1536
  --max-semi-space-size=64
  --expose-gc
  --optimize-for-size
  --gc-interval=100
"

# V8 í”Œë˜ê·¸ (ì¶”ê°€ ìµœì í™”)
export NODE_OPTIONS="$NODE_OPTIONS
  --no-opt
  --no-concurrent-recompilation
  --lite-mode
"

# í™˜ê²½ ë³€ìˆ˜
export LAZY_LOAD_ROUTES=true
export MAX_CACHE_SIZE_MB=256
export METRICS_INTERVAL=30000
export ENABLE_OBJECT_POOLING=true

# PM2ë¡œ ì‹œì‘ (ìë™ ì¬ì‹œì‘ í™œì„±í™”)
pm2 start ecosystem.config.js

# ë˜ëŠ” ì§ì ‘ ì‹¤í–‰
# node --expose-gc dist/index.js
javascript// ecosystem.config.js

module.exports = {
  apps: [{
    name: 'tburn-mainnet',
    script: './dist/index.js',
    instances: 1,
    
    // ë©”ëª¨ë¦¬ ì œí•œ
    max_memory_restart: '1800M',  // 1.8GB ì´ˆê³¼ ì‹œ ì¬ì‹œì‘
    
    // í™˜ê²½ ë³€ìˆ˜
    env_production: {
      NODE_ENV: 'production',
      LAZY_LOAD_ROUTES: 'true',
      MAX_CACHE_SIZE_MB: '256',
      METRICS_INTERVAL: '30000',
    },
    
    // ë¡œê·¸
    log_date_format: 'YYYY-MM-DD HH:mm:ss',
    error_file: './logs/error.log',
    out_file: './logs/out.log',
    merge_logs: true,
    
    // ì¬ì‹œì‘ ì •ì±…
    restart_delay: 3000,
    max_restarts: 10,
    min_uptime: '30s',
    
    // ê°ì‹œ
    watch: false,
    ignore_watch: ['node_modules', 'logs', 'data'],
  }]
};
```

---

## ğŸ“Š ì˜ˆìƒ ë©”ëª¨ë¦¬ ì ˆê° íš¨ê³¼

| ìµœì í™” í•­ëª© | í˜„ì¬ | ìµœì í™” í›„ | ì ˆê° |
|------------|------|----------|------|
| API ë¼ìš°íŠ¸ | 16-22 MB | 2-4 MB | ~18 MB |
| npm ì˜ì¡´ì„± | 100-200 MB | 60-100 MB | ~80 MB |
| MemStorage | 6-8 MB | 2-4 MB (LRU) | ~4 MB |
| ê°ì²´ ìƒì„± | ë§¤ë²ˆ new | í’€ë§ ì¬ì‚¬ìš© | GC ê°ì†Œ |
| ì›Œì»¤ ë¶„ë¦¬ | ë©”ì¸ì—ì„œ ì²˜ë¦¬ | ì›Œì»¤ì—ì„œ ì²˜ë¦¬ | ë©”ì¸ í™ ì ˆê° |
| **ì´ ì ˆê°** | | | **~100-150 MB** |

**ìµœì í™” í›„ ì˜ˆìƒ:**
```
V8 ì˜¤ë²„í—¤ë“œ:     600-800 MB (--lite-modeë¡œ ê°ì†Œ)
npm ì˜ì¡´ì„±:      60-100 MB
API ë¼ìš°íŠ¸:      2-4 MB (ì§€ì—° ë¡œë”©)
Storage ìºì‹œ:    256 MB (ì œí•œ)
ê¸°íƒ€:            50-100 MB
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ì´í•©:            ~1,000-1,300 MB / 2,096 MB
ì—¬ìœ :            ~800 MB (ì•ˆì •ì  ìš´ì˜ ê°€ëŠ¥)
```

---

## ğŸš€ ì ìš© ìˆœì„œ
```
1ë‹¨ê³„ (ì¦‰ì‹œ ì ìš© - ê³ íš¨ê³¼):
   â”œâ”€ ë¼ìš°íŠ¸ ì§€ì—° ë¡œë”©
   â””â”€ ë©”ëª¨ë¦¬ ê°€ë””ì–¸ í™œì„±í™”

2ë‹¨ê³„ (1ì¼ ë‚´):
   â”œâ”€ npm ì˜ì¡´ì„± ì •ë¦¬
   â””â”€ Node.js ì‹œì‘ ì˜µì…˜ ìµœì í™”

3ë‹¨ê³„ (3ì¼ ë‚´):
   â”œâ”€ LevelDB ê¸°ë°˜ Storage ì „í™˜
   â””â”€ ê°ì²´ í’€ë§ êµ¬í˜„

4ë‹¨ê³„ (1ì£¼ ë‚´):
   â””â”€ ì›Œì»¤ ìŠ¤ë ˆë“œ ë¶„ë¦¬